---
title: "Analysis of a genome annotation table"
author: "Jacques van Helden"
date: '`r Sys.Date()`'
output:
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: no
    smaller: yes
    theme: cerulean
    toc: yes
    toc_float: yes
    widescreen: yes
  html_document:
    self_contained: no
    code_folding: show
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_md: no
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  word_document:
    toc: yes
    toc_depth: 3
font-import: http://fonts.googleapis.com/css ?family=Risque
font-family: Garamond
subtitle: Probabilités et statistique pour la biologie (STAT1)
address: TAGC lab, Aix-Marseille Université, France
transition: linear
---

```{r setup, include=FALSE, size="huge"}
library(knitr)
## Default parameters for displaying the slides
knitr::opts_chunk$set(
  echo = TRUE, 
  eval = TRUE, 
  fig.width = 7, 
  fig.height = 5, 
  fig.align = "center", 
  fig.path = "figures/",
  size = "tiny", 
  warning = FALSE, 
  results = TRUE, 
  message = FALSE, 
  comment = "")

dir.main <- "~/stat1"
url.main <- "http://jvanheld.github.io/stat1"
dir.current <- file.path(dir.main, "practicals", "02_yeast_annotations")
setwd(dir.current)

```


## Goal of this practical

During this practical session, you will run the following tasks:

1. Handle a table containing annotated features of the yeast genome.
2. Select a subset of the data by filtering rows based on a given criterion (annotation type, chromosome, ...)
3. Generate graphics to represent different aspects of the data. 
4. Compute estimators of central tendency and dispersion. 
5. Compute a confidence interval around the mean. 



## Expected report

At the end of the practical you will be asked to submit two documents 


1. Your **R code**.Each question must be explicitly formulated before presenting the results that answer it and giving an interpretation of these results. 
2. UA  **synthetic report**, which will include a presentation of the main results (figures, descriptives stats, tables) as well as your interpretation of the result. 

### Expectation for the code


1. The code must be **readable and undestandable**: choose variable names that explicitly indicate what they represent.

2. The code must be properly documented (the `#` symbol starts a comment, either at the begining or in the middle of a line of code).

    - Before each chunk of code, explain what this code is supposed to do, what it serves to.
    
    - Don't hesitate to occasionally add some comment words to justify the chosen approach.
    
    - Each time you define a variable, add a comment on the same line to indicate what this variable represents.

3. The code must be  **portable**: other people should be able to download it and run it on their computer. For this practical, I will systematically test whether your code can run on my computer. hard-coded absolute paths of a file on your machine should thus always be avoided (we will indicate hereafter how to define relative paths relative to the root of your user account). 

### Expected content for the interpretation report

Your report must be synthetic (1 text page max + as many figures and table as you wish)
Le rapport doit être synthétique (1 page de texte maximum + autant de figures et tables que vous le désirez). 

Each question must be explicitly formulated before presenting the results that answer it and then interpreting those results.  
Chaque question doit être exprimée explicitement avant de présenter les résultats qui y répondent et de fournir l'interprétation de ces résultats. 

Each figure or table must be documented with a legend that allows a naive reader to understand what it represents. The interpretation of the results displayed on a figure or table will be found in the main text (with a reference to the figure or table number).
Chaque figure ou table doit être documentée par une légende permettant à un lecteur naïf de comprendre ce qu'elle représente. L'interprétation des résultats affichés sur une figure ou table se trouvera dans le texte principal (avec une référence au numéro de figure ou table). 

## Historical example: yeast genome

```{r load_yeast_cds_lengths, echo=FALSE}
## Read a GTF file
## Format specification: http://www.ensembl.org/info/website/upload/gff.html

## Download tab-delimited file with chromosome sizes (unless already there)
gtf.url <- "http://jvanheld.github.io/stat1/data/Saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz"
gtf.file <- file.path(dir.main, "data", "Saccharomyces_cerevisiae", "Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz")

if (file.exists(gtf.file)) {
  message("GTF annotation file: ", gtf.file)
} else {
  download.file(gtf.URL, destfile = gtf.file)
}

feature.table <- read.delim(gtf.file, comment.char = "#", sep="\t", header=FALSE, row.names=NULL)
names(feature.table) <- c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attribute")
# nrow(feature.table) ## Count feature number

## Select subset of features having "CDS" as "feature" attribute
cds <- subset(feature.table, feature=="CDS")
## nrow(cds) ## Count the number of "coding sequences", i.e. open reading frames annotated as cds

```

- 1992: publication of the first complete eukaryotic chromosome, the 3rd yeast chromosome. 
- 1996: publication of the complete genome.

On the base of the genes of the 3rd chromosome (sample) we can estimate the average size of a yeast gene. 

**Questions: ** 

(a) Would the sample mean (chromosome III) be sufficient to predict the population mean (complete genome) ? 

    To answer this question, we will imagine that we came back in 1992, and will use all the genes of chromosome III (considered here as a sample of the genome) to estimate the average size of genes for the whole genome (the "population" of genes").

(b) Can this sample be described as "simple and independent" ?

## Analysis of the length of the baker's yeast genes

```{r cds_length_histo, out.width="90%", fig.width=10, fig.height=4, fig.cap="Distribution of cds lengths for Saccharomyces cerevisiae. ", echo=FALSE}
par.ori <- par(no.readonly = TRUE)
par(mar = c(4.1,4.1,2.1,1.1))

## Add a column to the table with cds lengths
cds$length <- cds$end - cds$start +1
max.len <- max(cds$length)

## Select cds on the third chromosome
cds.III <- subset(cds, seqname == "III")
# View(cds.III)
par(mfrow=c(1, 2))

## Plot an histogram with cds lengths
hist(cds.III$length, 
     breaks=seq(from=0, to=max.len+100, by=100), 
     main="Chromosome III",
     xlab=NA, ylab="Number of cds", 
     col="#BBDDFF")

## Plot an histogram with cds lengths
hist(cds$length, 
     breaks=seq(from=0, to=max.len+100, by=100), 
     main="Full genome",
     xlab="cds length (bp)", ylab="Number of cds", 
     col="#BBFFDD")
par(mfrow=c(1,1))

par <- par.ori

```



## Tutorial

Before moving to the exercises, we show you here some basic elements about reading, manipulating and writing data tables with R.


### The path to the home (manual)

We will create a folder for this tutorial, starting from the root of our account.  

First possibility (**quick but not very elegant**):  enter (manually) the path from the root of your account in a variable

`dir.home <- /the/path/to/the/home`

- Advantage: fast and convenient
- Disadvantage: not portable, will only work on your computer

### The path to the home (automatic)

A more general solution: use the **R** command  `Sys.getenv()`.

- Invoked without parameters, this command lists all environment variables (your system configuration). 
- The output can be restricted to a given environment variable, for example `Sys.getenv("HOME")` returns the path to the root of your account.

**Note:** equivalent writing with Linux: the tilde symbol `~` also indicates the path to the root of your account. 

```{r get_home}
## Identify the home directory 
## by getting the environment variable HOME 
dir.home <- Sys.getenv("HOME")
print(dir.home)
```


### Creating a folder for the TP

```{r create_practical_dir}
## Define a variable containing the path of the results for this tutorial
dir.tuto <- file.path(dir.home, "stat1", "TP2")

print(dir.tuto)

## Create the directory for this tutorial
dir.create(path = dir.tuto, showWarnings = FALSE, recursive = TRUE)

## Go to the tutorial directory
setwd(dir.tuto)

## List the files already present in the folder (if any)
list.files()

```

### Downloading the GTF file from EnsemblGenomes

**Tips: ** before downloading the annotation file (GTF) from EnsemblGenomes to our computer, we will check if it is already present (and in this case we do not re-download it). 

```{r download_GTF}
## Define the URL of the annotation file (GTF-formatted)
gtf.URL <- "ftp://ftp.ensemblgenomes.org/pub/release-37/fungi/gtf/saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz"

## Define the path where the local copy will be stored
local.GTF <- file.path(dir.tuto, "Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz")

## If the local file file laready exists, skip the download
if (file.exists(local.GTF)) {
  message("GTF file already exists in the tutorial folder: ", local.GTF)
} else {
  ## Download annotation table in GTF format
  download.file(url = gtf.URL, destfile = local.GTF)
}
```

### Loading a data table

R has several types of tabular structures (matrix, data.frame, table).

The most commonly used structure is the `data.frame`, which consists of an array of values (numeric or strings) whose rows and columns are associated with names. 

The function `read.table()` allows you to read a text file containing a data table, and store the content in a variable.

Several functions derived from `read.table()` make it easier to read different types of formats:  

- `read.delim()` for files whose columns are delimited by a particular character (usually the tab, represented by "\t").
- `read.csv()` for files "comma-searated values".


1. Download the following file to your computer: 

- [Saccharomyces_cerevisiae.R64-1-1.37.gtf](../../data/Saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.37.gtf)

2. Load it using the read.table function (for this you must replace the path below by that of your computer). 

```{r read.table, echo=TRUE, result=TRUE}
## Read a GTF file with yeast genome annotations

## Load the feature table
feature.table <- read.table(
  local.GTF, 
  comment.char = "#", 
  sep="\t", 
  header=FALSE, 
  row.names=NULL)

## The bed format does not contain any column header, 
## so we set it manually based on the description of the format, 
## found here: 
##     http://www.ensembl.org/info/website/upload/gff.html
names(feature.table) <- c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attribute")


```

### Exploring the content of a data table

The first thing to do after loading a data table is to check its dimensions.

```{r echo=TRUE, result=TRUE, warning=FALSE}
dim(feature.table) ## Dimensions of the tbale
nrow(feature.table) ## Number of rows
ncol(feature.table) ## Number of columns
```

The display of the complete annotation table would not be very readable, since it contains tens of thousands of lines.  

We can display the first lines with the function `head()`. 

**Note: ** the last column is particularly heavy (it contains a lot of information). We will see later how to select a subset of the columns to simplify the display.  

```{r echo=TRUE, eval=TRUE, result=TRUE}
## Display the 5 first rows of the feature table
head(feature.table, n = 5) 
```

The function `tail()` displays the last few lines:

```{r echo=TRUE, eval=TRUE, result=TRUE}
## Display the 5 last rows of the feature table
tail(feature.table, n = 5) 
```

If you are using the **RStudio** environment, you can display the table in a dynamic viewer pane with the function  `View()`.

```{r echo=TRUE, eval=FALSE}
## In RStudio, display the table in a separate tab
View(feature.table) 
```


### Selection of subsets from a table

Selection of a line specified by its index.

```{r echo=TRUE, eval=TRUE, result=TRUE}
feature.table[12,]
```

Selection of a column specified by its index (display of the first values only).

```{r echo=TRUE, eval=TRUE, result=TRUE}
head(feature.table[,3])
```

Selection of a cell by combining row and column indices.

```{r echo=TRUE, eval=TRUE, result=TRUE}
feature.table[12, 3]
```

Selection of a column and/or row set.

```{r echo=TRUE, eval=TRUE, result=TRUE}
feature.table[100:105, 1:6]
```

Selection of specific columns (here, the genomic coordinates of each feature): chromosome, beginning, end, strand.

```{r echo=TRUE, eval=TRUE, result=TRUE}
feature.table[100:105, c(1,4,5,7)]
```

Select a column based on its name.

```{r echo=TRUE, eval=TRUE, result=TRUE}
## Select the "start" column and print the 100 first results
head(feature.table$start, n=100)

## Print the 20 first values of the "feature" field, which indicates the feature type
head(feature.table$feature, n=20)
```

Selection of several columns based on their names. 


```{r echo=TRUE, eval=TRUE, result=TRUE}
## Select the "start" column and print the 100 first results
feature.table[100:106, c("seqname", "start", "end", "strand")]
```

**Note**: Selection of several columns based on their names. It is also possible to name the rows of a data.frame but the GTF table does not support this. We will see more examples later.



### Selection of a subset of rows based on the content of a column

The function `subset()` allows you to select a subset of the rows of a data.frame based on a condition applied to one or more columns.

We can apply it to select the subset of rows in the annotation table corresponding to coding sequences (CDS).

```{r echo=TRUE, eval=TRUE, result=TRUE}
## Select subset of features having "cds" as "feature" attribute
cds <- subset(feature.table, feature=="cds")

nrow(feature.table) ## Count the number of features
nrow(cds) ## Count the number of cds
```

### Count by value

The function `table()` allows you to count the occurrences of each value in a vector or array. Some examples of use below.  

```{r echo=TRUE, eval=TRUE, results=TRUE}
## Count the number of featues per chromosome
table(feature.table$seqname)

## Count the number of features per type
table(feature.table$feature)
```

Contingency tables can be calculated by counting the number of combinations between 2 vectors (or 2 columns of a table). 

```{r echo=TRUE, eval=TRUE, results=TRUE}
##  Table with two vectors
table(feature.table$feature, feature.table$seqname)

## Same result with a 2-column data frame
table(feature.table[, c("feature", "seqname")])
```

## Exercises

### 1. GTF format specifications

Read the GTF format specifications.

- Ensembl (<http://www.ensembl.org/info/website/upload/gff.html>)
- UCSC (<https://genome.ucsc.edu/FAQ/FAQformat.html#format4>)

### 2. Creating a local folder for the TP

Create a local folder (for example: `stat1/TP_yeast` from the root of your account). We suggest you to use the following functions: 
 

- `Sys.getenv("HOME")` (Linnux and Mac OS X), to get the root of your user account;
- `file.path()` to build a path;
- `dir.create()` to create the folder for the TP
pour créer le dossier de ce TP. Lisez attendivement les options de cette fonction avec `help(dir.create)` 

### 3. Localisation du fichier d'annotations

Localisez le fichier d'annotations du génome de la levure en format GTF dans ce dossier local. 

- Site Ensembl Fungi: <http://fungi.ensembl.org/>
- Cliquez "Downloads" pour accéder au [site ftp](http://fungi.ensembl.org/info/website/ftp/)
- Dans la bo^îte de recherche, tapez *"saccharomyces cerevisiae"* et suivez le lien "[GTF](ftp://ftp.ensemblgenomes.org/pub/release-37/fungi/gtf/saccharomyces_cerevisiae)"
- COpiez l'adresse (URL) du ichier [Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz](ftp://ftp.ensemblgenomes.org/pub/release-37/fungi/gtf/saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.37.gtf.gz)


### 4. Téléchargement d'un fichier à partir d'un site ftp

Fonctions suggérées: 

- `download.file()` (lisez l'aide pour conna^tre les arguments)

### 5. Chargement d'une table de données en R

Ecrivez un script qui charge la table de données dans une variable nommée `feature.table`, en utilisant la fonction R `read.delim()`. 

Veillez à ignorer les lignes de commentaires (qui commencent par un caractère `#`). 


### 6. Calcul de la longueur des gènes codants


- Ajoutez à la table d'annotations (`feature.table`) une colonne intitulée "length" qui indique la longueur de chaque élément génomique annoté. 

```{r}
## Add a colmn with feature lengths
feature.table[, "length"] <- feature.table[, "end"] - feature.table[, "start"] + 1

## Add a colmn with feature lengths: equivalent result with simpler notation
feature.table$length <- feature.table$end - feature.table$start + 1
```


- Comptez le nombre de lignes de la table correspondant à chaque type d'annotation (3ème colonne du GTF, "feature"). 

    - fonction `table()`

```{r}
~table(feature.table$feature)
```


- Sélectionnez les lignes correspondant à des régions codantes ("CDS") 

    - fonction `subset()`

```{r}
cds <- subset(feature.table, feature=="CDS")
```


- Comptez le nombre de CDS par chromosome.

    - fonction `table()`


```{r}
table(cds$seqname)
```

- Chargez la table des tailles de chromosomes [chrom_sizes.tsv](../../data/Saccharomyces_cerevisiae/chrom_sizes.tsv), et calculez la densité de gènes pour chaque chromosome (nombre de gènes par Mb). 

```{r}
## Download tab-delimited file with chromosome sizes (unless already there)
annot.url <- "http://jvanheld.github.io/stat1/data/Saccharomyces_cerevisiae/chrom_sizes.tsv"
chrom.size.file <- file.path(dir.tuto, "chrom_sizes.tsv")

if (!file.exists(chrom.size.file)) {
    download.file(annot.url, destfile = chrom.size.file)
}

## Read chromosome sizes
chrom.size <- read.delim(
  file = chrom.size.file,
  header = FALSE, row.names = 1)

## Assign a name to the columns
names(chrom.size) <- c("chromID", "size")
# View(chrom.size)

## print the size of hte third chromosome
chrom.size["III", "size"]

```


### 6. Histogramme de la longueur des gènes

Au moyen de la fonction `hist()`, dessinez un histogramme représentant la distribution de longueur des CDS. 

```{r}
hist(cds$length)
```

Choisissez les intervalles de classe de façon à ce que l'histogramme soit informaatif (ni trop ni trop peu de classes).

```{r}
## Take more or less 100 bins
h <- hist(cds$length, breaks=100)


```

Récupérez le résultat de `hist()` dans une variable nommée `cds.length.hist`.

```{r}
## Define breaks exactly in the way you wish
cds.length.hist <- hist(cds$length, breaks=seq(from=0, to=max(cds$length)+100, by=100))

```


Imprimez le résultat à l'écran (`print()`) et analysez la structure de la variable `cds.length.hist` (il s'agit d'une variable de type liste). 

Fonctions utiles: 
```{r}
## Display the values used to draw the histogram
print(cds.length.hist )

```

- `class(cds.length.hist)`
- `attributes(cds.length.hist)`


D'autres types de graphiques permettent d'explorer la distribution d'un ensemble des données. En particulier, les boîtes à moustaches (box plots) affichent, pour une série de données, la médiane, l'écart interquartile, un intervalle de confiance et les valeurs aberrantes. 

```{r fig.width=7, fig.height=5, fig.cap="Boîte à moustache indiquant la distribution de longueur des gènes par chromosome. "}
boxplot(length ~ seqname, data = cds, col="palegreen", horizontal=TRUE, las=1, xlab="Gene length", ylab="Chromosome")

```

### 7. Paramètres descriptifs

Calculez les paramètres de tendance centrale (moyenne, médiane, mode) et de dispersion (variance, écart-type, écart inter-quartile) 

- pour les gènes du chromosome III;
- pour l'ensemble des gènes de la levure.


```{r}
x <- subset(cds, seqname == "III", select = "length")
dim(x) 
class(x) ## Ah ah, this is not a vector but a data.frame

## Convert the data frame into a vector
x <- unlist(x)
class(x)
head(x)

## Compute the mean, either manually or with the ad hoc R function
n <- length(x) 
print(paste("Chromosome III contains", n, "CDS"))
message("Chromosome III contains ", n, " CDS")

m <- mean(x)
print(m)
message("mean(x) = ", round(m, digits = 1))

## Compute the mean manually to compare the result
m.recalc <- sum(x)/n
message("Manually computed sample mean: ", round(digits=1, m.recalc))

## Compute manually standard dev of the sample
sample.var <- sum((x - m)^2)/ n
sample.sd <- sqrt(sample.var)
message("Sample standard dev =", round(digits=1, sample.sd))

## Compute an estimate of the population standard deviation
pop.sd.est <- sqrt(sum((x - m)^2) / (n-1))
message("Sample-based estimate of population standard dev =", round(digits=1, pop.sd.est))

## Compute the standard deviation with R function sd()
R.sd <- sd(x)
message("Result of R sd() function =", round(digits=1, R.sd))


```

**Ah ah! (skeptical tone)** The R function `sd()` does **not** compute the standard deviation of the input numbers ($s$), but the **estimate of the standard deviaiton of the population** ($\hat{\sigma}$)

Affichez ces paramètres sur l'histogramme de la longueur des gènes, en utilisant la fonction `arrows()`

### 8. Intervalle de confiance

A partir des gènes du chromosome III (considérés comme l'échantillon disponible en 1992), calculez un intervalle de confiance autour de la moyenne, et formulez l'interprétation de cet intervalle de confiance. 
Evaluez ensuite si cet intervalle de confiance recouvrait ou non la moyenne de la population (tous les gènes du génome de la levure, qui devint disponible 4 ans après le chromosome III). 

$$ \bar{x} \pm \frac{\hat{\sigma}}{\sqrt(n)} \cdot t_{1-\alpha/2}^{n-1}$$

```{r}
## Define alpha, the risk
alpha <- 0.05

## Let us get the critical value for the t distribution
help("TDist")

## Which value corresponds to alpha/2 

## Beware ! by default the qt() function return the lower tail
qt(p = alpha/2, df =  n - 1)

## For confidence intervals we need a positive t value, we thus take the upper tail
t.value <- qt(p = alpha/2, df =  n - 1, lower.tail = FALSE)

IC.min <- m - pop.sd.est * t.value /sqrt(n)
IC.max <- m + pop.sd.est * t.value /sqrt(n)

message("Confidence interval: [", 
        round(digits=1, IC.min), 
        ", ", 
        round(digits=1, IC.max), "]")

```

Dessinez un polygnone des fréquences indiquant le nombre de gènes par classe (milieux de classe). 

```{r}

## Draw a frequency polygon
plot(cds.length.hist $mids, cds.length.hist $counts, 
     main="Frequency polygon", 
     xlab="Gene length", ylab="Number of genes", 
     type="l", col="darkgreen", lwd=2, xlim=c(0, 5000))
grid()

arrows(x0 = IC.min, y0 = 100, x1 = IC.max, y1=100, length = 0, angle = 00, col="violet", lwd=3)
abline(v = m, col="violet")

pop.mean <- mean(cds$length)
abline(v = pop.mean, col="blue")

legend("topright", legend = c("genome", "chr3"), col = c("blue", "violet"), lwd=1)
```


### 9. Distribution de la longueur des gènes

- A partir du résultt de `hist()`, récupérez un tableau (dans une variable de type `data.frame`) indiquant les fréquences absolues (`count`) en fonction de la taille médiane des classes (`mids`),

- Ajoutez à ce tableau une colonne indiquant la fréquence relative de chaque classe de longueurs de gènes.

- Ajoutez à ce tableau des colonnes indiquant la **fonction de répartition empirique** des longueurs de gènes (nombre de gènes d'une taille inférieure ou égale à chaque valeur $x$ observée, et fréquence relative de ce nombre). 

    - fonction de base: `cumsum()`
    - fonction avancée;`ecdf()`
    
- Au moyen des fonctions `plot()` et `lines()`, dessinez un graphe représentant la fréquence absolue par classe (médianes de classes en $X$, comptages en $Y$), et la fonction de répartition empirique. 

    - suggestion: superposez les  utilisez le type de lignes "h" pour les fréquences de classe, et "l" ou "s" pour la fonction de répartition. 


### 10. Distribution attendue au hasard pour la longueur des gènes

Sur base de la taille du génome (12.156.679 bp) et des fréquences génomiques de codons définies ci-dessous, calculez la distribution de longueurs de gènes attendue au hasard, et ajoutez-là au graphique. 

Vous pouvez télécharger les fréquences génomiques de tous les  trinucléotides ici:  [3nt_genomic_Saccharomyces_cerevisiae-ovlp-1str.tab](http://jvanheld.github.io/stat1/data/Saccharomyces_cerevisiae/oligo_freq/3nt_genomic_Saccharomyces_cerevisiae-ovlp-1str.tab)

Alternative: créez une variable `freq.3nt` et assignez-y manuellement les valeurs pour les 4 nucléotides nécessaires, à partir de la table ci-dessous.


```{r echo=FALSE}
## Download tab-delimited file with chromosome sizes (unless already there)
freq.3nt.url <- "http://jvanheld.github.io/stat1/data/Saccharomyces_cerevisiae/oligo_freq/3nt_genomic_Saccharomyces_cerevisiae-ovlp-1str.tab"
freq.3nt.file <- file.path(dir.tuto, "3nt_genomic_Saccharomyces_cerevisiae-ovlp-1str.tab")

if (file.exists(freq.3nt.file)) {
  message("Trinucleotide frequency file: ", freq.3nt.file)
} else {
    download.file(freq.3nt.url, destfile = freq.3nt.file)
}


## Download oligonucleotide frequencies
oligo.freq <- read.table(freq.3nt.file, sep="\t", row.names = NULL)
colnames(oligo.freq) <- c("sequence", "frequency", "occurrences")
oligo.freq$frequency <- signif(digits=3, oligo.freq$frequency)

row.names(oligo.freq) <- oligo.freq$sequence

#oligo.freq["...",] <- c("...", "...", "...")

selected.oligos <- c("AAA", "ATG", "TAA", "TAG", "TGA")

kable(data.frame(oligo.freq[selected.oligos, ]), row.names = FALSE)
#print(data.frame(oligo.freq[selected.oligos, ]))
```


### 11. Avant de terminer : conservez la trace de votre session

La traçabilité constitue un enjeu essentiel en sciences. 
La fonction ***R***  `sessionInfo()` fournit un résumé des conditions d'une session de travail: version de R, système opérateur, bibliothèques de fonctions utilisées. 


```{r}
sessionInfo()
```

