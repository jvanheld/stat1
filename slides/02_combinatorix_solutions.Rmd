---
title: "Eléments d'analyse combinatoire - solutions des exercices"
author: "Jacques van Helden"
date: '`r Sys.Date()`'
output:
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: yes
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  html_document:
    code_folding: hide
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle: Probabilités et statistique pour la biologie (STAT1)
font-family: Garamond
transition: linear
---

```{r include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)
options(width=300)
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path='figures',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, eval=TRUE, 
  warning = FALSE, message = FALSE, 
  results = TRUE, comment = "")
# knitr::asis_output("\\footnotesize")

```

# Résumé des concepts et formules

## Tirages avec / sans remise

Il existe deux types classiques de tirage d'éléments au sein d'un ensemble: avec ou sans remise. 

1. **Tirage sans remise**: chaque élément peut être tiré au plus une fois. Exemples: 

    - Jeu de [loto](https://fr.wikipedia.org/wiki/Loto) (ou lotto). 
    - Sélection aléatoire d'un ensemble de gènes dans un génome. 

2. Tirage **avec remise**: chaque élément peut être tiré zéro, une ou plusieurs fois. Exemples: 

    - Jeu de dés. A chaque lancer on dispose des mêmes possibilités (6 faces).
    - Génération d'une séquence aléatoire, par sélection itérative d'un élément dans l'ensemble des résidus (4 nucléotides pour l'ADN, 20 acides aminés pour les protéines). 
    
## Formules

| Remise | Ordre | Formule | Description |
|--------|-------|------------|---------------------------------|
| Oui | Oui | $n^x$ | **Exponentielle**: séquences de $x$ éléments tirés dans un ensemble de taille $n$, avec remise. |
| Non | Oui | $n!$ | **Factorielle**: toutes les permutations d'un ensemble de taille $n$ |
| Non | Oui | $A^x_n = \frac{n!}{x!}$ | **Arrangements** : listes (ordonnée) de $x$ éléments tirés dans un ensemble de taille $n$ |
| Non | Non | $C^x_n = \binom{n}{x} = \frac{n!}{x! (n - x) !}$ | **Combinaisons** : ensembles (non ordonnés) de $x$ éléments tirés dans un ensemble de taille $n$ |


# Solutions des exercices

## Solution exercice 1: mutagenèse

*On soumet un fragment d'ADN de 1 kilobase à un traitement mutagène qui provoque des mutations ponctuelles (substitutions) à 5 positions distinctes indépendantes. Combien de séquences possibles existe-t-il pour le fragment muté ?*

Il s'agit de choisir  au hasard 5 positions mutantes parmi les 1000 nucléotides du fragment d'ADN. Il s'agit d'un choix sans remise (chaque position ne peut être tirée qu'une fois), on choisit donc le coefficient binomial.

$$\binom{n}{x} = \binom{1000}{5} = C^5_{1000} = \frac{1000!}{5! 995!} = `r choose(n=1000, k=5)`$$

## Solution de l'exercice 2 : oligopeptides $3 \times 20$

*Combien d'oligopeptides de taille 60 peut-on former en utilisant exactement 3 fois chaque acide aminé ?*

Commençons par générer une séquence particulière qui remplit ces conditions, en concaténant 3 copies de chaque acide aminé, dans l'ordre alphabétique. 

```{r echo=FALSE}
aa.table <- read.delim("amino_acid_table.tsv", sep="\t")
kable(aa.table, caption = "Symboles des acides aminés et codons")

aa <- sort(as.vector(aa.table$Symbol))
aa <- aa[aa %in% LETTERS]

cat(sort(rep(aa, times=3)), sep="")
```

Les permutations de ces 60 lettres sont des solutions valudes. En voici trois exemples. 

```{r echo=FALSE}
cat(sample(rep(aa, times=3)), sep="")
cat(sample(rep(aa, times=3)), sep="")
cat(sample(rep(aa, times=3)), sep="")
cat("...")
cat(sample(rep(aa, times=3)), sep="")
```

Le nombre total de permutations possibles parmi 60 éléments est $60! = `r factorial(60)`$. Cependant, cenombre dépasse de loin le nombre de séquences distinctes. En effet, dans chacune des séquences ci-dessus, chaque lettre apparaît 3 fois. Or, des permutations entre les trois positions occupées par des $A$ ne changeront pas la séquence. Il en va de même pour les permutations entre  les positions occupées par chacun des acides aminées : $A$, $C$, $D$, $\ldots$

Il faut donc diviser le nombre total de permutations ($60!$) par le nombre de permutations qui ne modifient pas la séquence: $3!$ pour $A$, $3!$ pour $D$, et ainsi de suite pour chacun des 20 acides aminés. 

La formule finale est donc: 

$$N = \frac{\overbrace{60!}^{\text{60 lettres}}}{\underbrace{3! \cdot 3! \cdot \ldots 3!}_{\text{20 acides aminés présents 3 fois}}} = \frac{60!}{(3!)^{20}} = `r factorial(60) / (factorial(3)^20)`$$



